/*********************************************************************************************
Copyright 2015 Real-Time Innovations, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
**********************************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;


/* For the Sparx Automation APIs see:
 * http://bellekens.com/2011/01/29/tutorial-create-your-first-c-enterprise-architect-addin-in-10-minutes/
 * https://alexatnet.com/articles/creating-addin-for-sparx-enterprise-architect
 * http://blog.sparxsystems.eu/2015/05/the-enterprise-architect-object-model-ea-api/
 * http://bellekens.com/writing-ea-add-ins/
 */

using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Drawing;
using EA;

namespace IDL4_EA_Extension
{
    public class IDLGenAction : UserActionInterface
    {
        private EA.Repository _currentRepository = null;
        private TextOutputInterface _currentOutput = null;
        private HashSet<string> _uncheckedElements = null;
        private IDLClassSelector _classSelector = null;

        public void Initialize(EA.Repository repository, TextOutputInterface output, IDLClassSelector classSelector,
            HashSet<string> uncheckedElements)
        {
            _currentRepository = repository;
            _currentOutput = output;
            _uncheckedElements = uncheckedElements;
            _classSelector = classSelector;
            this.OnIdlVersionAction(IDLVersions.defaultVersion);
            this.OnIdlMappingDetailAction(IDLVersions.defaultMappingDetails);
        }

        public void OnCodegenAction()
        {
            Main.GenIDL(_currentRepository, false, _currentOutput, _uncheckedElements);
        }

        public void OnSaveAction(string filePath)
        {
            String[] preambleLines = {
               "/*",
               " *  IDL file generated by RTI Connext DDS Enterprise Architect IDL 4 Add-in version 1.0",
               " *      Enterprise Architect File:  " + _currentRepository.ConnectionString,
               " *      Date: " + DateTime.Now.ToString(),
               " */",
               " "
            };

            _currentOutput.SaveToFile(filePath, preambleLines);
        }

        public void OnSelectAction(TreeNode treeNode)
        {
            OnDebugAction("Selected Node: " + treeNode.FullPath);
            Main.GenIDL_Preview(_currentRepository, _currentOutput, _uncheckedElements, treeNode.FullPath);
        }

        public void OnCheckAction(TreeNode treeNode)
        {
            // Remember whether it is uncheked or not
            if (treeNode.Checked)
            {
                _uncheckedElements.Remove(treeNode.FullPath);
            }
            else
            {
                _uncheckedElements.Add(treeNode.FullPath);
            }
        }

        public void OnIdlVersionAction( IDLVersion ver )
        {
            _currentOutput.Clear();

            Main.setIdlVersion(ver.Value);
        }

        public void OnIdlMappingDetailAction(IDLMappingDetail detail)
        {
            _currentOutput.Clear();

            Main.setIdlMappingDetail(detail.Value);
        }

        public void OnDebugAction(string text)
        {
            _currentOutput.OutputTextLine(text);
        }
    }

    /* This is a helper class to resolve a connector from the perspective of one of the
     * two elements that terminate the connector.
     * It resolves
     * - The referenced elementID
     * - The two connectors ends. "source" and "refernced element" 
     */
    class ReferenceDescriptor
    {
        public ReferenceDescriptor()
        {
            sourceElemEnd     = null;
            referencedElemEnd = null;
            referencedElemId  = 0;
            shouldBeIncludedInSourceElemClass = false;
            explanation       = null;
        }
        public ConnectorEnd  sourceElemEnd;
        public ConnectorEnd  referencedElemEnd;
        public int           referencedElemId;
        public bool          shouldBeIncludedInSourceElemClass;
        String               explanation;
    };

    /* This is a helper class to track that the IDL generation for a package or an class
     * has been completed
     * 
     *  Code generation for a package is completed when code generation has been completed
     *  for all contained classed and packages. This definition is recusive.
     */
    class CodegenCompleteDatabase
    {
        public CodegenCompleteDatabase(bool previewMode)
        {
            _previewMode = previewMode;
            if (_previewMode)
            {
                _completedClasses = null;
                _completedPackages = null;
            }
            else
            {
                _completedClasses = new HashSet<long>();
                _completedPackages = new HashSet<long>();
            }
        }    
 
        public CodegenCompleteDatabase() : this(true) { 
        }

        public void AddCompletedPackage(EA.Package package)
        {
            if (!_previewMode)
            { 
                _completedPackages.Add(package.PackageID);
            }
        }
        public void AddGeneratedClass(EA.Element element)
        {
            if (!_previewMode)
            {
                _completedClasses.Add(element.ElementID);
            }
        }

        /*
         * Checks if the package has been completely generated.
         * In Preview Mode the return is always FALSE so that the
         * preview resurses into nested packages
         */
        public bool IsPackageComplete(EA.Package package)
        {
            if ( _previewMode )
            {
                return false;
            }
            return _completedPackages.Contains(package.PackageID);
        }

        /*
         * Checks if the class has been completely generated.
         * In Preview Mode the return is always FALSE so that 
         * it generates the class
         */
        public bool IsClassGenerated(EA.Element element)
        {
            if ( _previewMode )
            {
                return false;
            }
            return _completedClasses.Contains(element.ElementID);
        }

        /*
         * Checks if the class that corresponds to an ID has been completely generated.
         * In Preview Mode the return is always TRUE because this is used to check 
         * dependencies on other classes and we need this to allow generation of the class
         */
        public bool IsClassIdGenerated(int referencedElemId)
        {
            if  (_previewMode )
            {
                return true;
            }
            return _completedClasses.Contains(referencedElemId);
        }

        private bool          _previewMode;
        private HashSet<long> _completedClasses;
        private HashSet<long> _completedPackages;
    };


    [ComVisible(true)]
    public class Main
    {
        private const String IDL_GENERATOR_REVISION = "1.21";
        private const String MENU_ROOT_RTI_CONNEXT  = "- IDL4  (RTI Connext DDS)";
        private const String MENU_ITEM_GENERATE_IDL = "Generate IDL ...";

        private static int idlVersion = IDLVersions.defaultVersion.Value;
        private static int idlMappingDetail = IDLVersions.defaultMappingDetails.Value;



        // Called Before EA starts to check Add-In Exists
        public string EA_Connect(Repository repository)
        {
            // nothing special
            return "EaProjectStats.AddIn - connected";
        }
        // EA calls this operation when it exists. Can be used to do some cleanup work.
        public void EA_Disconnect()
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }

        // Called when user Click Add-Ins Menu item.
        public object EA_GetMenuItems(Repository repository,
            string location, string menuName)
        {
            switch (menuName)
            {
                case "":
                    return MENU_ROOT_RTI_CONNEXT;
                case MENU_ROOT_RTI_CONNEXT:
                    return MENU_ITEM_GENERATE_IDL;
            }
            return "";
        }

        // Sets the state of the menu depending if there is
        // an active project or not
        static bool EA_IsProjectOpen(Repository repository)
        {
            try
            {
                return null != repository.Models;
            }
            catch
            {
                return false;
            }
        }

        // Called once Menu has been opened to see what menu
        // items are active.
        public void EA_GetMenuState(Repository repository,
            string location, string menuName, string itemName,
            ref bool isEnabled, ref bool isChecked)
        {
            if (EA_IsProjectOpen(repository))
            {
                if (itemName == MENU_ROOT_RTI_CONNEXT)
                    isEnabled = true;
            }
            else
                // If no open project, disable all menu options
                isEnabled = false;
        }

        // Called when user makes a selection in the menu.
        // This is your main exit point to the rest of your Add-in
        public void EA_MenuClick(Repository repository,
            string location, string menuName, string itemName)
        {

            switch (itemName)
            {
                case MENU_ITEM_GENERATE_IDL:
                    IDLGenAction idlGenAction = new IDLGenAction();
                    IDLClassSelector idlClassSelector = new IDLClassSelector(idlGenAction);
                    TextBoxOutputAdapter output = new TextBoxOutputAdapter(idlClassSelector.getTextBox());
                    HashSet<string> uncheckedElements = new HashSet<string>();
                    idlGenAction.Initialize(repository, output, idlClassSelector, uncheckedElements);

                   // GenerateIDL(repository, output);

                    PopulateRepositoryClassSelector(idlClassSelector, repository);
                    idlClassSelector.Text = "IDL4 (RTI Connext DDS) - Select classes for IDL generation - Plugin revision " + IDL_GENERATOR_REVISION;
                    idlClassSelector.Show();
                    //idlGenAction.OnCodegenAction();
                    break;
            }
        }

        /* 
         * This function populates a TreeNode representing a package with all the children
         * types. Currently classes and enumerations.
         */
        public static void PopulatePackageClassesAndEnums(TreeNode packageTreeNode, Package package)
        {
           foreach (Element e in package.Elements)
            {
                if (IsClass(e) || IsElementEnum(e))
                {
                    TreeNode classNode = new TreeNode(e.Name);
                    classNode.Checked = true;
                    packageTreeNode.Nodes.Add(classNode);
                    // PopulateClassSubtypes(classNode, e);
                }
            }
        }


        /* 
         * This function populates a TreeNode representing a class with all the children
         * types. In some cases classes may have nested classes.
         * 
         * This is currently unused.
         */
        public static void PopulateClassSubtypes(TreeNode classTreeNode, Element classElement)
        {
            foreach (Element e in classElement.Elements)
            {
                TreeNode subelementNode = new TreeNode(e.Name);
                subelementNode.Checked = true;
                classTreeNode.Nodes.Add(subelementNode);
            }
        }

        /*
         * *** This feature is not fully implemented so it is not used.***
         * 
         * The longer term objective would be to use this event to re-sync all the classes/enum with the model but only
         * at that level, not recursively
         */
        public static void ClassSelector_TreeViewAfterExpand(object sender, TreeViewEventArgs e)
        {
            return;
        }

        /*
         * This function polates the Class Selector Tree view with all the packahs and classes in the model
         */
        public static void PopulateRepositoryClassSelector(IDLClassSelector classSelector, Repository repository)
        {
            TreeNodeCollection treeNodes = classSelector.getTreeView().Nodes;


            foreach (Package model in repository.Models)
            {
                TreeNode newNode = new TreeNode(model.Name);
                newNode.Checked = true;
                newNode.Expand();
                newNode.Tag = model.Name;
                treeNodes.Add(newNode);

                foreach (Package package in model.Packages)
                {
                    PopulateClassSelector(newNode, package);
                }
            }

            // Disble because feature is not fully implemeted yet
            //classSelector.getTreeView().AfterExpand += new TreeViewEventHandler(ClassSelector_TreeViewAfterExpand);
        }

        /*
         * This function recurseively populates a TreeNode in the class selector with all the
         * children of the specified package (the children may themselves be packages, classes, or other types)
         */
        public static void PopulateClassSelector(TreeNode parentNode, Package package)
        {
            TreeNode packageNode = new TreeNode(package.Name);
            packageNode.Checked = true;
            packageNode.Tag = package.Name;  // Store the related package
            parentNode.Nodes.Add(packageNode);

            foreach (Package p in package.Packages)
            {
                PopulateClassSelector(packageNode, p);
            }

            PopulatePackageClassesAndEnums(packageNode, package);
            packageNode.Expand();
        }

        /** Finds a child of an EA Model element capturing exceptions raised if the child is not
         * found.
         *
         */
        private static Object EAUtil_FindChild(EA.Collection collection, String childName)
        {
            Object child = null;
            try {
                child = collection.GetByName(childName);
            }
            catch (Exception) {}

            return child;
        }

        internal static void GenIDL_Preview(Repository repository, TextOutputInterface output,
            HashSet<string> uncheckedElem, String fullPath)
        {
            char[] delimiterChars = { '\\'};
            String[] elementNames = fullPath.Split(delimiterChars);
            String pathToElement = "";

            if (elementNames.Length <= 1)
            {
                GenIDL(repository, true, output, uncheckedElem);
                return;
            }

            Package package = (Package)EAUtil_FindChild(repository.Models, elementNames[0]);
            if (package == null)
            {
                output.OutputTextLine("// Could not find selected package: \"" + fullPath + "\" in the model");
                return;
            }

            Package parentPackage = package;
            Element  classElem = null;
            for (int i = 1; i < elementNames.Length; ++i, parentPackage = package)
            {
                String elemName = elementNames[i];

                package = (Package)EAUtil_FindChild(parentPackage.Packages, elemName);

                if ((package == null) && (i == elementNames.Length - 1))
                {
                    classElem = (Element)EAUtil_FindChild(parentPackage.Elements, elemName);
                }
            }

            output.Clear();
            if (package == null && classElem == null)
            {
                output.OutputTextLine("// Could not find selected element: \"" + fullPath + "\" in the model");
                return;
            }

            pathToElement = elementNames[0];
            for (int i = 1; i < elementNames.Length - 1; ++i)
            {
                output.OutputText("module " + IDL_NormalizeUserDefinedClassifierName(elementNames[i]) + " {  ");
                pathToElement += "\\" + elementNames[i];
            }

            output.OutputTextLine();
            if (package != null)
            {
                // display package
                // output.OutputTextLine("Displaying Package: " + package.Name);
                Dictionary<long, bool> moduleRelevance = new Dictionary<long, bool>();
                CodegenCompleteDatabase dummyCompletedDB = new CodegenCompleteDatabase(true);
                UpdateModuleRelevance(moduleRelevance, package, output);

                Main.GenIDL_ModuleFirstPass(repository, package, true,
                    output, elementNames.Length - 1, pathToElement, uncheckedElem, moduleRelevance, dummyCompletedDB);
                int generatedItemCount;

                Main.GenIDL_ModuleSecondPass(repository, package, true,
                    output, elementNames.Length - 1, pathToElement,
                    out generatedItemCount, uncheckedElem, moduleRelevance, dummyCompletedDB);
            }
            else if (classElem != null)
            {
                // display class
                // output.OutputTextLine("Displaying Class: " + classElem.Name);
                if (IsElementEnum(classElem))
                {
                    Main.GenIDL_Enum(repository, classElem, output, elementNames.Length - 1, uncheckedElem, pathToElement);
                }
                else if (IsXSDSimpleType(classElem))
                {
                    Main.GenIDL_XSDSimpleType(repository, classElem, null, output, elementNames.Length - 1);
                }
                else if (IsXSDTopLevelAttribute(classElem))
                {
                    Main.GenIDL_XSDTopLevelAttribute(repository, classElem, null, output, elementNames.Length - 1);
                }
                else 
                {
                    Main.GenIDL_Class(repository, classElem, output, elementNames.Length - 1, uncheckedElem, pathToElement);
                }
            }
            for (int i = 1; i < elementNames.Length - 1; ++i)
            {
                output.OutputText("};");
            }
        }

        private static String UML_EXTENSION_MODULE_NAME = "UML_Extension";
        private static String UNRESOLVED_TYPE_NAME = "ErrorUnresolvedType";

        /** Outputs UML "primitive" types that are not primitive in IDL
         * 
         */
        private static void GenIDL_PrebuiltUMLTypes(TextOutputInterface output)
        {
     
            String builtinTypes = 
                "module " + UML_EXTENSION_MODULE_NAME + " { " + Environment.NewLine +
                "    // Place the type declarations below" + Environment.NewLine +
                "    typedef string    " + UNRESOLVED_TYPE_NAME + "; " + Environment.NewLine +
                "    typedef long long dateTime;" + Environment.NewLine +
                "};";

            // Uncomment the lines below types are added to UML_Extension
            
            output.OutputTextLine("/* ******************************************************************* */");
            output.OutputTextLine("/* These are UML builtin primitive types that are not primitive in IDL */");
            output.OutputTextLine(builtinTypes);
        }

        internal static void GenIDL(Repository repository, bool isPreview, TextOutputInterface output, HashSet<String> uncheckedElem)
        {
            output.Clear();

            GenIDL_PrebuiltUMLTypes(output);
            output.OutputTextLine("");

            output.OutputTextLine("/* ******************************************************************* */");
            output.OutputTextLine("/* These are Types defined in the model */");
            output.OutputTextLine("");

            // moduleRelevance holds the modules relevant for IDL generation
            Dictionary<long, bool> moduleRelevance = new Dictionary<long, bool>();

            // completionDB holds the classes and packages for which code
            // generation has been completed

            CodegenCompleteDatabase completionDB = new CodegenCompleteDatabase(false);
            foreach (Package model in repository.Models)
            {
                if ((!isPreview) && uncheckedElem.Contains(model.Name))
                {
                    // if unckecked skip this model
                    continue;
                }

                UpdateModuleRelevance(moduleRelevance, model, output);
            }

            foreach (Package model in repository.Models)
            {
                if ((!isPreview) && uncheckedElem.Contains(model.Name))
                {
                    // if unckecked skip this model
                    continue;
                }

                output.OutputTextLine("/* -----  Model: \"" + model.Name + "\"  ----- */");
                foreach (Package package in model.Packages)
                {
                    GenIDL_ModuleFirstPass(repository, package, false,
                        output, 0, model.Name, uncheckedElem, moduleRelevance, completionDB);
                }
            }

            int notGeneratedClassCount = -1;        // Does not matter as long as it is < 0
            int previousNotGeneratedClassCount;

            do {
                previousNotGeneratedClassCount = notGeneratedClassCount;
                notGeneratedClassCount = 0;

                foreach (Package model in repository.Models)
                {
                    if ((!isPreview) && uncheckedElem.Contains(model.Name))
                    {
                        // if unckecked skip this model
                        continue;
                    }

                    foreach (Package package in model.Packages)
                    {
                        int generatedItemCount;
                        notGeneratedClassCount += GenIDL_ModuleSecondPass(repository, package, false,
                            output, 0, model.Name,
                            out generatedItemCount, uncheckedElem, moduleRelevance, completionDB);
                    }
                }
            }
            while ( (notGeneratedClassCount > 0) && (notGeneratedClassCount != previousNotGeneratedClassCount) ) ;


            if (notGeneratedClassCount > 0 )
            {
                output.OutputTextLine("/* WARNING: " + notGeneratedClassCount + " classes could not be generated due to circular dependencies */");
                GenIDL_ReportUngeneratedClasses(repository, output, 0, uncheckedElem, moduleRelevance, completionDB);
            }
        }


        private static void GenIDL_ReportUngeneratedClasses(Repository repository,
            TextOutputInterface output, int depth,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules, CodegenCompleteDatabase completionDB)
        {

            output.OutputTextLine("/*");
            output.OutputTextLine("     (<package> , <class>)  depends on (<package> , <class>) by means of <relationship>");
            output.OutputTextLine("     ----------------------------------------------------------------------------------");
            foreach (Package model in repository.Models)
            {
                if (uncheckedElem.Contains(model.Name))
                {
                    // if unchecked skip this model
                    continue;
                }

                foreach (Package package in model.Packages)
                {
                    GenIDL_ReportUngeneratedClasses(repository, package, output, 0, model.Name, uncheckedElem, relevantModules, completionDB);
                }
            }
            output.OutputTextLine("     -----------------------------------------------------------------------------------");
            output.OutputTextLine("*/");
        }

        private static void GenIDL_ReportUngeneratedClasses(Repository repository, Package package,
            TextOutputInterface output, int depth, String pathToElem,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules, CodegenCompleteDatabase completionDB)
        {
            // if unchecked skip this model
            String packageFullName = IDL_FullElementName(pathToElem, package.Name);
            if (IsElementUnchecked(uncheckedElem, packageFullName))
            {
                return;
            }

            if (!IsModuleRelevant(relevantModules, package, output))
            {
                return;
            }

            String moduleName = IDL_NormalizeUserDefinedClassifierName(package.Name);
            foreach (Element e in package.Elements)
            {
                if (!IsElementEnum(e))
                {
                    if ( (completionDB.IsClassGenerated(e) == false )
                        && GenIDL_MustGenerateClass(repository, e, packageFullName, uncheckedElem, null,  output, depth) )
                    {
                        GenIDL_DependenciesAlreadyGenerated(repository, e, output, completionDB, true);
                    }
                }
            }

            foreach (Package p in package.Packages)
            {
                GenIDL_ReportUngeneratedClasses(repository, p, output, depth + 1, packageFullName, uncheckedElem, relevantModules, completionDB);
            }
        }

        /*
         * This function identifies the classes created from an XSDsimpleType. 
         * These are mapped to a typedef in the IDL
         */
        private static bool IsXSDSimpleType(Element classElem)
        {
            return classElem.HasStereotype("XSDsimpleType");
        }

        /*
         * This function identifies the classes created from an XSDtopLevelAttribute. 
         * These are mapped to a typedef in the IDL
         */
        private static bool IsXSDTopLevelAttribute(Element classElem)
        {
            return classElem.HasStereotype("XSDtopLevelAttribute");             
        }

        /*
         * This function identifies the classes created from an XSDattributeGroup. 
         * These may need to handled specially.
         */
        private static bool IsXSDAttributeGroup(Element classElem)
        {
            return classElem.HasStereotype("XSDattributeGroup");             
        }
       
        /*
         * This function identifies the classes created from an XSDunion. 
         * These may need to handled specially.
         */
        private static bool IsXSDUnion(Element classElem)
        {
            return classElem.HasStereotype("XSDunion");             
        }

        /*
         * This function to identify XSD elemenst that are mapped to a Typedef.
         * Currently these are the XSD simple types and the top-level attributes 
         */
        private static bool IsXSDTypeMappedToTypedef(Element classElem)
        {
            // Check if this was a XSD simpleType or a XSD top level attribute.
            return IsXSDSimpleType(classElem) || IsXSDTopLevelAttribute(classElem);
        }

        //TODO: IDL_XSDprimitive2IDLprimitive should be deprecated. Use IDL_NormalizeMemberTypeName() instead
        private static readonly string[] xsd_longTypes = new string[] { "long", "int", "integer", "negativeInteger", "nonPositiveInteger" };
        private static readonly string[] xsd_ulongTypes = new string[] { "unsigned long", "unsignedLong", "unsignedInt", "positiveInteger", "nonNegativeInteger" };
        private static readonly string[] xsd_ushortTypes    = new string[] { "unsigned short", "unsignedShort" };
        private static readonly string[] xsd_octetTypes     = new string[] { "octet", "byte", "unsignedByte", "sbyte" };
        private static readonly string[] xsd_stringTypes = new string[] { "string", "normalizedString", "hexBinary", "base64Binary" };

        private static readonly string[][] xsd_primtiveTypeVariations = {
                xsd_longTypes, xsd_ulongTypes, xsd_ushortTypes, xsd_octetTypes, xsd_stringTypes
        };

        // These are some types that we hardcode based on their name and their base-class name
        private static readonly string[] xsd_builtinOctet2TypesTypedef = new string[] { "typedef octet HexBinary16[2]", "HexBinary16", "hexBinary"};
        private static readonly string[][] xsd_builtinTypedefs = {
                xsd_builtinOctet2TypesTypedef
        };

        private static String IDL_NormalizeXSDbuiltinTypes(String  typeName)
        {
            return IDL_NormalizeMemberTypeNameClassiffiedID0(typeName);
        }

        private static String IDL_XSDbuiltin2IDLdeclaration(String classifierName, String baseClassifierName)
        {
            // First check if it is one of the well-known builtin types
            for (int typeFamily = 0; typeFamily < xsd_builtinTypedefs.GetLength(0); ++typeFamily)
            {
                if (xsd_builtinTypedefs[typeFamily][1].Equals(classifierName) 
                    && xsd_builtinTypedefs[typeFamily][2].Equals(baseClassifierName) )
                {
                    return xsd_builtinTypedefs[typeFamily][0] + ";";
                }

            }

            // These we determine based only on the base classifier name
            for (int typeFamily = 0; typeFamily < xsd_primtiveTypeVariations.GetLength(0); ++typeFamily)
            {
                if (xsd_primtiveTypeVariations[typeFamily].Contains(baseClassifierName))
                {
                    return  "typedef " + xsd_primtiveTypeVariations[typeFamily][0] + " " + classifierName + ";";
                }
            }
            return null;
        }

        /*
         * Extracts the name of the parent from the GenLinks attribute.
         * This is needed from XADSimpleType
         * See http://sparxsystems.com/forums/smf/index.php/topic,30258.0.html             
         */
        private static String GenIDL_getBaseClassFromGenLinksParent(Element classElem,
            TextOutputInterface output, int depth)
        {
            String baseClassName = null;
            String parentIdentifier = "Parent=";
            String genLinks = classElem.Genlinks;
            if (genLinks == null)
            {
                return null;
            }

            int parentBeginIndex = genLinks.IndexOf(parentIdentifier);

            if (parentBeginIndex >= 0)
            {
                parentBeginIndex += parentIdentifier.Length;
                int parentEndIndex = genLinks.IndexOf(";", parentBeginIndex);
                if (parentEndIndex < 0)
                {
                    parentEndIndex = genLinks.Length;
                }

                baseClassName = genLinks.Substring(parentBeginIndex, parentEndIndex - parentBeginIndex);
            }

            return baseClassName;
        }

        /*
         * This function genearates a typedef declaration where appropriate
         */
        private static void GenIDL_ClassTypedef(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {
            output.OutputTextLine(depth, "struct " + IDL_NormalizeUserDefinedClassifierName(classElem.Name) + ";");
        }

        /** Generate IDL4 module corresponding to the UML package
         *
         *  This function is the first-pass module generation. It generates the things that
         *  have no dependencies on anything else and help resolve dependencies for the types
         *  that depend on this module. These are:
         *
         *  enums
         *  
         *  typedefs for XSD SimpleTypes. 
         *      They may appear defined inside other classes/structures
         *      They may appear defined inside XSDtopLevelAtribute
         *      
         *  typedefs for all structures defined in the module.
         *
         *  This function is recursive. It generates IDL for all the nested UML packages as well
         */
        private static void GenIDL_ModuleFirstPass(Repository repository, Package package, bool forceSelection,
            TextOutputInterface output, int depth, String pathToElem,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules, CodegenCompleteDatabase completionDB)
        {
            // if unckecked skip this model
            String packageFullName = IDL_FullElementName(pathToElem, package.Name);
            if ( (!forceSelection) && IsElementUnchecked(uncheckedElem, packageFullName))
            {
                return;
            }

            if ( !IsModuleRelevant(relevantModules, package, output) )
            {
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "/* Skipping empty module: \"" + package.Name + "\" */");
                }
                return;
            }

            String moduleName = IDL_NormalizeUserDefinedClassifierName(package.Name);
            bool emptyModuleContent = true;
            output.OutputTextLine(depth, "module " + moduleName + " {");

            // Due to possible interdependencies it is best to do the generation in
            // in successive passes

            // Generate typedef for enums and structures
            if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
            {
                output.OutputTextLine(depth, "/* Generating Enums and forward struct declarations */");
            }

            foreach (Element e in package.Elements)
            {
                if (IsElementUnchecked(uncheckedElem, packageFullName, e.Name))
                {
                    continue;
                }

                if (IsElementEnum(e))
                {
                    GenIDL_Enum(repository, e, output, depth + 1, uncheckedElem, packageFullName);
                    //if (completionDB != null ) {
                        completionDB.AddGeneratedClass(e);
                    //}
                    emptyModuleContent = false;
                }
                else if (GenIDL_MustGenerateClass(repository, e, packageFullName, uncheckedElem, completionDB, output, depth))
                {
                        GenIDL_ClassTypedef(repository, e, output, depth + 1);
                        emptyModuleContent = false;
                }
            }

            foreach (Element e in package.Elements) 
            {
                if (IsXSDSimpleType(e))
                {
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth+1, "/* Mapping to typedef because of stereotype <<XSDsimpleType>> */");
                    }

                    GenIDL_XSDSimpleType(repository, e, null, output, depth + 1);
                    completionDB.AddGeneratedClass(e);
                    emptyModuleContent = false;
                }  
            }

            // Generate typedef for XSDtopLevelAttribute
            foreach (Element e in package.Elements)
            {
                if (IsXSDTopLevelAttribute(e))
                {
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth + 1, "/* Mapping to typedef because of stereotype <<XSDtopLevelAttribute>> */");
                    }

                    GenIDL_XSDTopLevelAttribute(repository, e, null, output, depth + 1);
                    completionDB.AddGeneratedClass(e);
                    emptyModuleContent = false;
                }
            }

            // Generate typedef for XSDsimpleElement that appear nested within a class
            foreach (Element e in package.Elements)
            {
                bool generatedElements = false;
                if (GenIDL_MustGenerateClass(repository, e, packageFullName, uncheckedElem, null, output, depth))
                {
                    generatedElements = GenIDL_NestedSimpleElementTypedefs(repository, e, output, depth, completionDB);
                }
                emptyModuleContent = false;
            }

            // Recursively Generate First-Pass on the Nested Packages
            foreach (Package p in package.Packages)
            {
                GenIDL_ModuleFirstPass(repository, p, false,
                    output, depth + 1, packageFullName, uncheckedElem, relevantModules, completionDB);
                emptyModuleContent = false;
            }

            if (emptyModuleContent)
            {
                GenIDL_EmptyModuleContent(moduleName, output, depth + 1);
            }
            output.OutputTextLine(depth, "}; /* module " + moduleName + " */");
            output.OutputTextLine();
        }

        /** Generate IDL4 module corresponding to the UML package
         *
         *  This function is recursive. It generates IDL for all the nested UML packages and classes
         *
         * Returns the number of classes for which IDL could not be generated due to dependencies.
         *
         * The IDL for a class "C" can only be generated if we have already generated the IDL for all
         * the classes "C" depends on. This is determined by the return of the function:
         * GenIDL_DependenciesAlreadyGenerated()
         *
         * A return of "0" indicates there were no relevant classes for which the IDL could not be
         * generated. That is, the IDL generation is complete.
         *
         * A return >0 indicates IDL generation is not complete. In this case the GenIDL_ModuleSecondPass()
         * could be called again to generate additional classes that may have had their dependent
         * classes generated in the previous pass.
         *
         * If two successive calls to GenIDL_ModuleSecondPass() return the same value. That is, no progress
         * was made in on pass, this indicates there is a cyclic dependency that cannot be resolved.
         * In this case the strategy is to report the error so the user can break the dependency by, for example,
         * declaring on of the dependencies in the link as "@Shared"
         */
        private static int GenIDL_ModuleSecondPass(Repository repository, Package package, bool forceSelection,
            TextOutputInterface output, int depth, String pathToElem, out int generatedItemCount,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules, CodegenCompleteDatabase completionDB)
        {
            int notGeneratedClassCount = 0;
            generatedItemCount = 0;

            // if unckecked skip this model
            String packageFullName = IDL_FullElementName(pathToElem, package.Name);
            if ( (!forceSelection) && IsElementUnchecked(uncheckedElem, packageFullName) )
            {
                return 0;
            }

            if (!IsModuleRelevant(relevantModules, package, output))
            {
                return 0;
            }

            if (completionDB.IsPackageComplete(package))
            {
                return 0;
            }

            String moduleName = IDL_NormalizeUserDefinedClassifierName(package.Name);

            int moduleOutputPosition = output.GetCurrentPosition();
            output.OutputTextLine(depth, "module " + moduleName + " {");

            foreach (Element e in package.Elements)
            {
                if (GenIDL_MustGenerateClass(repository, e, packageFullName, uncheckedElem, completionDB, output, depth))
                {
                    if ( GenIDL_DependenciesAlreadyGenerated(repository, e, output, completionDB, false) )
                    {
                        GenIDL_Class(repository, e, output, depth + 1, uncheckedElem, packageFullName);
                        ++generatedItemCount;
                        completionDB.AddGeneratedClass(e);
                    }
                    else
                    {
                        ++notGeneratedClassCount;
                    }
                }
            }

            foreach (Package p in package.Packages)
            {
                int subModuleGeneratedItemCount;
                int submoduleNonGenClassCount = GenIDL_ModuleSecondPass(repository, p, false,
                    output, depth + 1, packageFullName,
                    out subModuleGeneratedItemCount, uncheckedElem, relevantModules, completionDB);
                notGeneratedClassCount += submoduleNonGenClassCount;
                generatedItemCount += subModuleGeneratedItemCount;

                if (submoduleNonGenClassCount == 0)
                {
                    // module is complete
                    completionDB.AddCompletedPackage(p);
                }
            }

            if (generatedItemCount == 0)
            {
                GenIDL_EmptyModuleContent(moduleName, output, depth + 1);
                output.ClearPositionRange(moduleOutputPosition, output.GetCurrentPosition());
            }
            else
            {
                output.OutputTextLine(depth, "}; /* module " + moduleName + " */");
                output.OutputTextLine();
            }

            return notGeneratedClassCount;
        }


        /* Generate the IDL for an enum literal.
         */
        private static void GenIDL_EnumLiterals(Repository repository, String enumName, Element enumElem, TextOutputInterface output, int depth)
        {
            short childCount = enumElem.Attributes.Count;
            for (short i = 0 ; i < childCount; ++i )
            {
                EA.Attribute child = enumElem.Attributes.GetAt(i);
                // String typeName = IDL_NormalizeMemberTypeName(child.Type);

                // Handle enumeration values. The "default value set in UML takes precedence
                // if not then look at the tag Value
                int value;
                String valueAnnotation = null;
                if (Int32.TryParse(child.Default, out value))
                {
                    valueAnnotation = child.Default;
                    // output.OutputText(" //@Value " + child.Default);
                }
                else
                {
                    string[] relevantAnnotationsWithValue = new string[] {
                        "ID", "Value"
                    };

                    foreach (AttributeTag tag in child.TaggedValues)
                    {
                        String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name);
                        if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                        {
                            valueAnnotation = tag.Value;
                        }
                    }
                }

                if ( (idlVersion >= IDLVersion.IDL_V410_CONNEXT53) && (valueAnnotation != null) )
                {
                    GenIDL_Annotation("Value", valueAnnotation, true, output, depth);
                }

                output.OutputText(depth, enumName + "_" + IDL_NormalizeUserDefinedClassifierName(child.Name));

                if ((idlVersion == IDLVersion.IDL_V350_CONNEXT52) && (valueAnnotation != null))
                {
                    output.OutputText(" = " + valueAnnotation);
                }
                if (i < childCount - 1)
                {
                    output.OutputText(",");
                }

                if ((idlVersion == IDLVersion.IDL_V350_XTYPES) && (valueAnnotation != null))
                {
                    GenIDL_Annotation("Value", valueAnnotation, true, output, depth);
                }

                output.OutputTextLine();
            }
        }

        private static String GenIDL_GetFullPackageName(Repository repository, Element elem)
        {
            String packageName = "";
            int packageID = elem.PackageID;
            Package package = repository.GetPackageByID(packageID);
            int parentPackageID = package.ParentID;

            while (parentPackageID != 0)
            {
                packageName = IDL_NormalizeUserDefinedClassifierName(package.Name) + "::" + packageName;
                packageID = parentPackageID;
                package = repository.GetPackageByID(packageID);
                parentPackageID = package.ParentID;
            }

            return packageName;
        }

        /* Generate the IDL for a nested element
         * This happens for example when we convert from an XSD that has elements defined inline as simple types
         */
        private static bool GenIDL_NestedElements(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {
            bool generatedElements = false;

            if (classElem.Elements.Count == 0)
            {
                return false;
            }

            // So far we only need to generate members  nested elements for XSD unions. Other types have explicit attributes
            // for each member and the nested elements only represent embedded type declarations which we already handles
            // generating typedef. See GehIDL_NestedSimpleElementTypedefs()
            if ( !IsXSDUnion(classElem) )
            {
                return false;
            }

            String parentName = classElem.Name;
            foreach (Element child in classElem.Elements)
            {
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "// Generating member because of nested element");
                }
                String typeName = GenIDL_GetTypeOfXSDSimpleType(repository, child, parentName, output, depth);
                output.OutputTextLine(depth, typeName + "  " + child.Name + ";");

                generatedElements = true;
            }

            return generatedElements;
        }

        /* Generate a typedef for each nested XSDsimpleElement that is declared in-line within a type
         * This happens for example when we convert from an XSD that has elements defined inline as simple types
         */
        private static bool GenIDL_NestedSimpleElementTypedefs(Repository repository, Element classElem,
            TextOutputInterface output, int depth,
            CodegenCompleteDatabase completionDB)
        {
            bool generatedElements = false;

            if (classElem.Elements.Count == 0)
            {
                return false;
            }

            String parentName = classElem.Name;
            foreach (Element child in classElem.Elements)
            {
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth + 1, "// Generating typedef because nested element defines a XSDsimpleType");
                }
                String baseClassifierName  = GenIDL_GetTypeOfXSDSimpleType(repository, child, parentName, output, depth);
                String classifierName = parentName + "_" + child.Name;

                // Check if it is one of the builtin types
                String typeDeclaration = IDL_XSDbuiltin2IDLdeclaration(classifierName, baseClassifierName);
                if (typeDeclaration == null)
                {
                    typeDeclaration = "typedef " + baseClassifierName + " " + classifierName + ";";
                }
                output.OutputTextLine(depth + 1, typeDeclaration);

                // if (completionDB != null) {
                    completionDB.AddGeneratedClass(child);
                // }

                generatedElements = true;
            }
           
            return generatedElements;
        }

        /* Generate the IDL for an attribute.
         * The attribute can appear by itself, a sequence, or an array.
         * The determination of this is based on the settings of LowerBound and UpperBound
         *
         *    UpperBound == 0                 ==>  Unbounded Sequence
         *    LowerBound == UpperBound == 1        ==>  Single member (no Array/Sequence)
         *    LowerBound == 0 && UpperBound == 1   ==>  Optional single member
         *
         *    LowerBound  < UpperBound  (other values)    ==>  Bounded Sequence
         *    LowerBound == UpperBound  (other values)    == > Array
         *
         * returns true if it outputs some attribute; otherwise returns false
         */
        private static bool GenIDL_Attributes(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {
            if (classElem.Attributes.Count == 0)
            {
                return false;
            }

            // These need to be handled specially
            bool isXSDattributeGroup = IsXSDAttributeGroup(classElem);
            int memberIndex = 0;

            foreach (EA.Attribute child in classElem.Attributes)
            {
                // This does not get the fully qualified type name. We need that to fully resolve
                // the type in the IDL...
                String typeName;

                /* This code was trying to get the fully-qualified name but it throws an exception
                 */
                if ( child.ClassifierID == 0 ) {
                    typeName = IDL_NormalizeMemberTypeNameClassiffiedID0(child.Type);
                }
                else {
                    Element attributeTypeElem = repository.GetElementByID(child.ClassifierID);
                    String packageName = GenIDL_GetFullPackageName(repository, attributeTypeElem);
                    String attributeTypeName = null;

                    if (attributeTypeElem.ParentID == classElem.ElementID)
                    {
                        // The attribute type is defined nested in the container class
                        // in that case the type was generated as a typedef with the class name as prefix.
                        attributeTypeName = IDL_NormalizeUserDefinedClassifierName(classElem.Name) 
                            + "_" + IDL_NormalizeMemberTypeName(attributeTypeElem.Name);
                    }
                    else
                    {
                        // The attribute type is either an external class, or a builtin type
                        if (packageName.Equals("")) {
                            // In this case attribute type is builtin type. Normalize the builtin name
                            attributeTypeName = IDL_NormalizeMemberTypeName(attributeTypeElem.Name);
                        }
                        else
                        {
                            // In this case attribute type is a user-defined type. Normalize the name
                            // removing illegal characters
                            attributeTypeName = IDL_NormalizeUserDefinedClassifierName(attributeTypeElem.Name);
                        }
                    }
                    typeName = packageName + attributeTypeName;
                }

                int lower  = 0;
                int upper  = 0;
                try {
                    lower = Convert.ToInt32(child.LowerBound);
                } catch (Exception) {}
                try {
                    upper = Convert.ToInt32(child.UpperBound);
                } catch (Exception) { }

                int attributeDepth = depth;

                String effectiveTypeName   = typeName;
                String effectiveMemberName = child.Name;
                String extraAnnotation = null;

                // In the case of XSDAttributeGroup the generated UML class has all members with the same name
                // this is illigal. As a workaround we append a number to each member name to make it unique.
                if (isXSDattributeGroup)
                {
                    effectiveMemberName += ++memberIndex;
                }

                if (upper == 0) // Unbounded sequence
                {
                    //output.OutputText(attributeDepth, "sequence<" + typeName + "> " + child.Name + ";");
                    effectiveTypeName = "sequence<" + typeName + ">";
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth, "// Mapping to unbounded sequence because (upper bound == 0)");
                    }

                }
                else if (lower == upper)
                {
                    if (upper != 1)  // Array
                    {
                        effectiveMemberName = child.Name + "[" + child.UpperBound + "]";
                        if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                        {
                            output.OutputTextLine(depth, "// Mapping to array because (lower bound == upper bound)");
                        }
                    }
                }
                else if (lower == 0 && upper == 1)
                {
                    // Handle this the same as an @optional annotation
                    extraAnnotation = "Optional";
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth, "// Mapping to optional because (lower bound == 0 && upper bound == 1)");
                    }

                }
                else // bounded sequence
                {
                    effectiveTypeName = "sequence<" + typeName + "," + child.UpperBound + ">";
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth, "// Mapping to bounded sequence because (lower bound < upper bound)");
                    }
                }

                GenIDL_AttributeWithAnnotations(child, effectiveTypeName, effectiveMemberName, extraAnnotation, output, depth);
                output.OutputTextLine();
            }

            return true;
        }

        private static void GenIDL_AttributeWithAnnotations(EA.Attribute child,
            String effectiveType, String effectiveName, String extraAnnotation,
            TextOutputInterface output, int depth)
        {
            int annotationCount = 0;
            if (idlVersion >= IDLVersion.IDL_V410_CONNEXT53)
            {
                annotationCount = GenIDL_AttributeAnnotations(child, output, depth);
                if (extraAnnotation != null)
                {
                    GenIDL_Annotation(extraAnnotation, annotationCount==0, output, depth);
                    ++annotationCount;
                }
            }
            output.OutputText(depth, effectiveType + " " + effectiveName + ";");

            if (idlVersion < IDLVersion.IDL_V410_CONNEXT53)
            {
                annotationCount = GenIDL_AttributeAnnotations(child, output, depth);
                if (extraAnnotation != null)
                {
                    GenIDL_Annotation(extraAnnotation, annotationCount==0, output, depth);
                    ++annotationCount;
                }
            }
        }

        /*
         * This outputs an annotation that has no paramaters
         */
        private static void GenIDL_Annotation(
            String annotationName, bool firstAnnotation,
            TextOutputInterface output, int depth)
        {
            GenIDL_Annotation(annotationName, null, firstAnnotation, output, depth);
        }


        /*
         * Maps annotations names and parameters from their normalized form to the
         * syntax specific to the version of IDL.
         *          * 
         */
        private static void GenIDL_MapAnnotation(
            String normalizedAnnotationName, String normalizedAnnotationParam1,
            out String mappedAnnotationName, out String mappedAnnotationParam1)
        {
            if ( (idlVersion == IDLVersion.IDL_V350_CONNEXT52 ) && normalizedAnnotationName.Equals("nested") )
            {
                mappedAnnotationName = "top-level";
                if ( (normalizedAnnotationParam1 == null ) || normalizedAnnotationParam1.ToLower().Equals("true") )
                {
                    mappedAnnotationParam1 = "FALSE";
                }
                else
                {
                    mappedAnnotationParam1 = "TRUE";
                }
            }
            else
            {
                mappedAnnotationName   = normalizedAnnotationName;
                mappedAnnotationParam1 = normalizedAnnotationParam1;
            }
        }

        /*
         * This outputs an annotation with zero or one paramater.
         * 
         * - annotationName. The normalized name of the annotation
         * 
         * - annotationParam1. The value of the annotation paramater. May be null if the
         *   annotation does not have any parameters
         *   
         * - firstAnnotation. Indicates whether this is the first annotation being generated for the class or
         *   the member. This affects the formatting for IDLVersion.IDL_V350_CONNEXT52
         */
        private static void GenIDL_Annotation(
            String annotationName, String annotationParam1, bool firstAnnotation,
            TextOutputInterface output, int depth)
        {
            // Depending on the version of IDL annotations need to be mapped
            String mappedAnnotationName;
            String mappedAnnotationParam1;
            GenIDL_MapAnnotation(annotationName, annotationParam1, out mappedAnnotationName, out mappedAnnotationParam1);

            if (idlVersion >= IDLVersion.IDL_V410_CONNEXT53)
            {
                output.OutputText(depth, "@" + mappedAnnotationName.ToLower());
                if ( (mappedAnnotationParam1 != null) && !mappedAnnotationParam1.Equals("") ) 
                {
                    output.OutputText("(" + mappedAnnotationParam1 + ") ");
                }
                //output.OutputTextLine();
            }
            else if (idlVersion >= IDLVersion.IDL_V350_XTYPES)
            {
                output.OutputText("  //@" + mappedAnnotationName);
                if ( (mappedAnnotationParam1 != null) && !mappedAnnotationParam1.Equals("") )
                {
                    output.OutputText("(" + mappedAnnotationParam1 + ") ");
                }
            }
            else // IDLVersion.IDL_V350_CONNEXT52
            {
                if (firstAnnotation)
                {
                    output.OutputText("  //@" + mappedAnnotationName);
                }
                else {
                    // output.OutputTextLine();
                    output.OutputText(depth, "    //@" + mappedAnnotationName);
                }

                if ( (mappedAnnotationParam1 != null) && !mappedAnnotationParam1.Equals("") )
                {
                    output.OutputText(" " + mappedAnnotationParam1);
                }
            }
        }

        /** Outputs the annotations associated with the attribute
         *
         * Returns the number of annotations printed
         */
        private static int GenIDL_AttributeAnnotations(EA.Attribute child, TextOutputInterface output, int depth)
        {
            string keyAnnotation = "Key";
            string[] relevantAnnotationsNoValue = new string[] {
                    keyAnnotation,
                    "must_understand",
                    "autoid", "Optional",
                    "external",
                    "oneway", "ami"
                };
            string[] relevantAnnotationsWithValue = new string[] {
                    "ID", "Value"
                };

            string ddsTag = "DDS";

            Boolean mappedToKey = false;
            int annotationCount = 0;

            foreach (AttributeTag tag in child.TaggedValues)
            {
                String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name);

                // Accept the TagName DDS as an alternative way to provide an accepted no value annotation
                // So {Tag, Value} = {"DDS", "XYZ"} is equivalent to {"XYZ", }
                if (normalizedAnnotation.Equals(ddsTag))
                {
                    normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Value);
                }

                if (relevantAnnotationsNoValue.Contains(normalizedAnnotation))
                {
                    GenIDL_Annotation(normalizedAnnotation, annotationCount==0, output, depth);
                    ++annotationCount;
                    if ( normalizedAnnotation.Equals(keyAnnotation) ) {
                        mappedToKey = true;
                    }
                }
                else if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                {
                    GenIDL_Annotation(normalizedAnnotation, tag.Value, annotationCount == 0, output, depth);
                    ++annotationCount;
                }
                else
                {
                    if ((idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL))
                    {
                        output.OutputTextLine(depth, "/* Skipping unknown annotation name: \"" + tag.Name + "\" value: \"" + tag.Value + "\" */");
                    }
                }
            }

            // Accept the attributes marked as ID as being "Key"
            if ( (!mappedToKey) && child.IsID )
            {
                mappedToKey = true;
                GenIDL_Annotation(keyAnnotation, annotationCount == 0, output, depth);
                ++annotationCount;
                if ((idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL))
                {
                    output.OutputTextLine(depth, "/* Mapping to @Key because attribute has the IsID property set */");
                }
            }


            return annotationCount;
        }

        /*
         * Determinies member name used when a member is created as a result of a reference to some other class/element
         * The member name is chosen following a set of rules to it is the "most natural one" accoding to whether the user
         * has explicitly named the role, reference, etc.
         * The criteria is:
         *   - Use the rolename if present
         *   - Else use the relationship name
         *   - Else use the name of the target class starting with lower case, or preceeded with a "m_"
         *   
         * Names are always normalized to prevent using characters that would be invalid as a member name
         * When the classname is used a "numeric suffix" is used to prevent multiple references to the same
         * class resulting on member name collisions
         * 
         */
        private static String GenIDL_GetReferenceName(EA.Connector conn, EA.ConnectorEnd referencedElemEnd, EA.Element referencedElem)
        {
            // Note that in some cases referencedElem.Name is null. E.g. when the referenced element is a Note
            if ((referencedElem == null) || (referencedElem.Name == null) || referencedElem.Name.Equals(""))
            {
                return "unamedReferencedElement";
            }

            String refName = referencedElemEnd.Role;
            if (refName.Equals(""))
            {
                refName = conn.Name;
            }
            if (refName.Equals(""))
            {
                char firstLetter = referencedElem.Name[0];
                if (char.IsUpper(firstLetter))
                {
                    refName = char.ToLower(firstLetter) + referencedElem.Name.Substring(1);
                }
                else
                {
                    refName = "m_" + referencedElem.Name;
                }
            }

            return IDL_NormalizeUserDefinedClassifierName(refName);
        }

        /*
         * Returns a description of the reference relationship along with a decision on
         * whether the referenced element should appear as a member of the source element.
         * 
         * Background on UML Associations:
         * http://www.uml-diagrams.org/association.html
         * 
         * To appear as a member the relationship must:
         * - Be "Association", "Aggregation", or "Nesting"
         * - Be navigable to the referenced element
         * - Have (source) aggregation property of "shared" or "composite"
         * - We do not look at the TARGET role containment. It does not matter if it is 
         *   value, reference, or unspecified
         *                                                                       referencedElem
         *    +-------------------+  sourceElemEnd       referencedElemEnd  +-----------------+
         *    |  sourceElementId  | ----------------------------------------| targetElementId |
         *    +-------------------+               conn                      +-----------------+
         *    
         *                                 memberName (computed from relationship name)
         *                                 
         * The funtion fills the output paramaters as follows:
         * 
         * - includeInSourceElem. Set to TRUE if the target class should be included as 
         *   a member of the source class. If it is set to FALSE the member will not appear and
         *   the explantion out parameter will be filled.
         *   
         * - explanation. Contains the explanation of why tha target class is not included
         *   as a member of the source class. Filled if and only if includeInSourceElem = FALSE
         *   and explain = TRUE.
         *   
         * - sourceElemEnd. The connectorId corresponding to the sourceElemId. Note that in the
         *   UMM model it could be either the SOURCE or TARGET connector. But this function
         *   normalized it so it it seen from the perspectibe of the sourceElemId. 
         *   
         * - referencedElemId. The ElementId of the element at the other side of the relationship
         *   from the point of view of the sourceElemId.
         *  
         * - memberName. The name of the member that would be generated. This is filled even if
         *   the relationship does not cause a member to be generated, that way the member name
         *   can be used in the log messages.
         * 
         * - referencedElem. The Element corresponding to the referencedElemId. If 
         *   includeInSourceElem = TRUE, then the referenced element will be a valid element in 
         *   the repository as this is checked as a condition for includeInSourceElem=TRUE.
         */
        private static void GenIDL_ReferenceDescriptor(
            EA.Repository repository, EA.Connector conn, int sourceElemId, bool explain,
            out EA.ConnectorEnd sourceElemEnd, out EA.ConnectorEnd referencedElemEnd, 
            out int referencedElemId, out EA.Element referencedElem,
            out String memberName, out bool includeAsReference,
            out bool includeInSourceElem, out String explanation,
            TextOutputInterface output, int depth)
        {
            includeInSourceElem = false;
            explanation = null;
            memberName = null;
            includeAsReference = false;

            /* Normalize the relationship identofyign the source and target roles */
            if (sourceElemId == conn.ClientID)
            {
                sourceElemEnd = conn.ClientEnd;
                referencedElemEnd = conn.SupplierEnd;
                referencedElemId = conn.SupplierID;
            }
            else
            {
                sourceElemEnd = conn.SupplierEnd;
                referencedElemEnd = conn.ClientEnd;
                referencedElemId = conn.ClientID;
            }

            referencedElem = repository.GetElementByID(referencedElemId);
            if (referencedElem == null)
            {
                if (explain)
                {
                    explanation = "target element with ElementID = " + referencedElemId + " is not found in UML Repository";
                }
                return;
            }

            memberName = GenIDL_GetReferenceName(conn, referencedElemEnd, referencedElem);

            // Only consider "Aggregation", "Association", and "Nesting" relationships as reasons to include the
            // referenced element as a member
            string[] relevantConnectorTypes = new string[] { "Association", "Aggregation", "Nesting" };
            if (!relevantConnectorTypes.Contains(conn.Type))
            {
                if (explain)
                {
                    explanation = "association type is '" + conn.Type + "' instead of 'Association', 'Aggregation', or 'Nesting'";
                }
                return;
            }

            if (referencedElemEnd.IsNavigable == false)
            {
                if (explain)
                {
                    explanation = "target role Navigability property is false";
                }
                return;
            }

            if (sourceElemEnd.Aggregation == 0)
            {
                if (explain)
                {
                    explanation = "source role Aggegation property is 'none' instead of 'shared' or 'composite'";
                }
                return;
            }

            /*
            if (conn.Type.Equals("Association") && !referencedElemEnd.Containment.Equals("Value"))
            {
                if (explain)
                {
                    explanation = "target role containment type is '"  + referencedElemEnd.Containment + "' instead of 'Value'";
                }
                return;
            }
            */

            // Determine if the referenced element is "by value" or "by reference"
            // sourceElemEnd.Aggregation can be 0, 1, 2 for  none, shared, composite. See http://www.sparxsystems.com/enterprise_architect_user_guide/12.1/automation_and_scripting/connectorend.html

            // Note that we alredy know that sourceElemEnd.Aggregation != 0. Otherwise we are not generating the member
            if ((referencedElemEnd.Containment.Equals("Reference"))
                 || (referencedElemEnd.Containment.Equals("Unspecified") && sourceElemEnd.Aggregation == 1 ))
            {
                includeAsReference = true;
            }
            else // in this case either Containment.Equals("Reference") or sourceElemEnd.Aggregation == 2
            {
                includeAsReference = false;
            }

            includeInSourceElem = true;
            return;
        }

        /**
         * Given a class (sourceClass) that is being mapped to IDL, this function is invoked on each reference (connector). 
         * that the sourceClass has to determine if the reference/connector should result on a member being added to sourceClass.
         * 
         * The function returns the fully qualified (and normalized) name for the type referenced by the connector in case 
         * the referenced type needs to be included as a member of the "sourceClass". If there is no member to be included as
         * a result of the reference/connector the function returns the null string.
         * 
         * In addition to the name of the referenced element the function returns the annotations that the member should have.
         *
         * Paramaters:
         * - sourceClass. This is the class that is being mapped to IDL
         * - conn. A connector for sourceClass
         * - (out) memberName. The member being generated. 
         *   type if the multiplicity of the relationship requires that.
         * - (out) annotations. The annotations on the member.
         * - (return value) the memberType for memberName. The memberType includes fully-scoped typenames
         *   as well as any needed sequences 
         */
        private static String GenIDL_GetReferencedTypeToInclude(
            out List<String> annotations, out String memberName,
            Repository repository,
            Element sourceClass, EA.Connector conn, TextOutputInterface output, int depth)
        {
            annotations   = null;
            memberName    = null;

            // Generalization (Inheritance) does not cause the referenced element to 
            // appear as member. This is well understood so no need to report more details on why
            if (conn.Type.Equals("Generalization"))
            {
                return null;
            }

            Element referencedElem;
            ConnectorEnd thisElemEnd;
            ConnectorEnd referencedElemEnd;
            int referencedElemId;
            String explanation;
            bool includeReferencedTypeAsMember;
            bool includeAsReference;

            bool reportExplanationText = idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_BASIC;

            // This resolves the details of the reference and determines whether a member should be
            // generated of not.
            GenIDL_ReferenceDescriptor(repository, conn, sourceClass.ElementID, reportExplanationText,
                out thisElemEnd, out referencedElemEnd, out referencedElemId, out referencedElem, 
                out memberName, out includeAsReference,
                out includeReferencedTypeAsMember, out explanation,
                output, depth);

            if ( !includeReferencedTypeAsMember ) {
                if ( reportExplanationText ) {
                    String referencedElementClassName = "Unknown Type";
                    if (referencedElem != null)
                    {
                        referencedElementClassName = referencedElem.Name;
                    }

                    output.OutputTextLine(depth, "/* Skipping reference \"" + memberName
                        + "\" to element \"" + referencedElementClassName + "\" because " + explanation + " */");
                }
                return null;
            }

            /* If we are here we know includeReferencedTypeAsMember == TRUE
             * this means referenced class as a member of this element 
             * and also that referencedElem != null as this is checked by GenIDL_ReferenceDescriptor() */
            String memberTypeScoped = null;
            String cardinality = referencedElemEnd.Cardinality;
           

            String normalizedMemberType = IDL_NormalizeUserDefinedClassifierName(referencedElem.Name);
            memberTypeScoped = GenIDL_GetFullPackageName(repository, referencedElem) + normalizedMemberType;

            // Apply cardinality rules. Can cause member to be @Optional, or a sequence
            if (cardinality.Equals("0..1"))
            {
                // Zero or one -> Optional
                if (annotations == null )
                {
                    annotations = new List<String>();
                }
                annotations.Add("@Optional");
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "/* Mapping to Optional because relation cardinality == \"0..1\" */");
                }
            }
            else if (cardinality.Equals("*") || cardinality.EndsWith("..*") || cardinality.EndsWith(".."))
            {
                // No upper limit -> unbounded sequence
                memberTypeScoped = "sequence<" + memberTypeScoped + ">";
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "/* Mapping to unbounded sequence because relation cardinality is \"*\", \"..*\", or \"..\" */");
                }
            }
            else if (cardinality.Equals("") || cardinality.Equals("1") || cardinality.Equals("0"))
            {
                // Map to regular member. No sequence, no optional
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "/* Mapping to regular member because relation cardinality is \"\", \"1\", or \"0\" */");
                }
            }
            else
            {
                // Bounded sequence
                int upperLimit = 0;
                if (Int32.TryParse(cardinality, out upperLimit))
                {
                    if (upperLimit <= 0) { upperLimit = 1; }
                    memberTypeScoped = "sequence<" + memberTypeScoped + "," + upperLimit + ">";
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth, "/* Mapping to bounded sequence because relationship cardinality = "
                                                    + cardinality + " (lower bound < upper bound) */");
                    }
                }
                else
                {
                    int limitPos = cardinality.LastIndexOf("..");
                    if ((limitPos != -1) &&
                            Int32.TryParse(cardinality.Substring(limitPos + 2), out upperLimit))
                    {
                        memberTypeScoped = "sequence<" + memberTypeScoped + "," + upperLimit + ">";
                        if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                        {
                            output.OutputTextLine(depth, "/* Mapping to bounded sequence because relationship cardinality = "
                                                        + cardinality + " (lower bound < upper bound) */");
                        }
                    }
                    else
                    {
                        memberTypeScoped = "sequence<" + memberTypeScoped + ">";
                        if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                        {
                            output.OutputTextLine(depth, "/* Mapping to unbounded sequence because relationship cardinality = "
                                                        + cardinality + " */");
                        }
                    }
                }

            }

            // Members included by reference are mapped to the @Shared annotation 
            if (includeAsReference)
            {
                if (idlVersion == IDLVersion.IDL_V350_CONNEXT52)
                {
                    memberTypeScoped = memberTypeScoped + "*";
                }
                else // Otherwise use an annotation
                {
                    if (annotations == null)
                    {
                        annotations = new List<String>();
                    }
                    annotations.Add("@Shared");
                }
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "/* Mapping to Shared because Containment is 'Reference' or Aggregation is 'Shared' */");
                }
            }

            return memberTypeScoped;
        }

        //TODO: This should examine the relationship and determine the multiplicity so that
        //      the relationship can be generated as a sequence rather than single reference.
        private static bool GenIDL_Relations(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {
            bool generatedRelationship = false;

            foreach (EA.Connector conn in classElem.Connectors)
            {
                List<String> annotations = null;
                String refname = null;
                String referencedType = GenIDL_GetReferencedTypeToInclude(out annotations, out refname, repository, classElem, conn, output, depth);

                if (referencedType != null)
                {
                    if (annotations != null)
                    {
                        if (idlVersion >= IDLVersion.IDL_V410_CONNEXT53)
                        {
                            output.OutputText(depth, annotations[0].ToLower() + " ");
                            for (int i = 1; i < annotations.Count; ++i)
                            {
                                output.OutputText(annotations[i].ToLower() + " ");
                            }
                            output.OutputTextLine(referencedType + "  " + refname + "; ");
                        }
                        else
                        {
                            output.OutputTextLine(depth, referencedType + "  " + refname + "; //" + annotations[0]);
                            for (int i=1; i< annotations.Count; ++i)
                            { 
                                output.OutputTextLine(depth, "//" + annotations[i]);
                            }
                        }
                    }
                    else
                    {
                        output.OutputTextLine(depth, referencedType + "  " + refname + ";");
                    }
                    generatedRelationship = true;
                }
            }

            return generatedRelationship;
        }

        private static String IDL_FullElementName(String elementPath, String elementName)
        {
            return elementPath + "\\" + elementName;
        }

        private static bool IsElementUnchecked(HashSet<String> uncheckedElem, String elementFullName)
        {
            return (uncheckedElem != null) && (uncheckedElem.Contains(elementFullName));
        }

        private static bool IsElementUnchecked(HashSet<String> uncheckedElem, String elementPath, String elementName)
        {
            if (uncheckedElem == null)
            {
                return false;
            }
            return uncheckedElem.Contains(IDL_FullElementName(elementPath, elementName));
        }

        private static bool IsElementEnum(Element elem)
        {
            return elem.Type.Equals("Enumeration") || elem.Stereotype.Equals("enumeration");
        }

        /**
         *  This function traverses the package, recursively visiting all its children, and updates
         *  the moduleRelevance dictionary storing whether each individual module is relevant or not
         *
         * Relevance is currently defined as not being empty for the purposes of IDL generation. This
         * means having some class, some enumeration, or recursively containing a relevant sub-package
         */
        private static bool UpdateModuleRelevance(Dictionary<long, bool> moduleRelevance, Package package,
            TextOutputInterface output)
        {
            bool relevantModule = false;

            foreach (Package p in package.Packages)
            {
                relevantModule = UpdateModuleRelevance(moduleRelevance, p, output) || relevantModule;
            }

            if (relevantModule == false)
            {
                foreach (Element e in package.Elements)
                {
                    if (IsElementEnum(e) || IsClass(e))
                    {
                        relevantModule = true;
                        break;
                    }
                }
            }
            moduleRelevance.Add(package.PackageID, relevantModule);

            return relevantModule;
        }

        private static bool IsModuleRelevant(Dictionary<long, bool> moduleRelevance, Package package, TextOutputInterface output)
        {
            bool isRelevant = true;
            if (!moduleRelevance.TryGetValue(package.PackageID, out isRelevant))
            {
                output.OutputTextLine("IsModuleRelevant; Error did not find: " + package.Name);
                return true;
            }
            return isRelevant;
        }

        private static void GenIDL_Enum(Repository repository, Element enumElem,
             TextOutputInterface output, int depth,
             HashSet<String> uncheckedElem, String elementPath)
        {
            String enumNameNormalized = IDL_NormalizeUserDefinedClassifierName(enumElem.Name);
            output.OutputTextLine(depth,
                "enum " + enumNameNormalized + " {");

            //output.OutputTextLine(depth, "/* elementID = " + enumElem.ElementID + " */");
            GenIDL_EnumLiterals(repository, enumNameNormalized, enumElem, output, depth + 1);
            output.OutputTextLine(depth, "};");
        }


        private static String GenIDL_GetTypeOfXSDSimpleType(Repository repository, Element elem, String parentName,
             TextOutputInterface output, int depth)
        {
            String baseClassName = GenIDL_getBaseClassFromGenLinksParent(elem, output, depth);

            if (baseClassName == null)
            {
                baseClassName = GetIDL_getBaseClass(repository, elem);
            }
            else
            {
                baseClassName = IDL_NormalizeXSDbuiltinTypes(baseClassName);
            }

            return baseClassName;
        }


        private static void GenIDL_XSDSimpleType(Repository repository, Element elem, String parentName,
             TextOutputInterface output, int depth)
        {
            String baseClassName = GenIDL_GetTypeOfXSDSimpleType(repository, elem, parentName, output, depth);

            if (baseClassName == null)
            {
                baseClassName = UML_EXTENSION_MODULE_NAME + "::" + UNRESOLVED_TYPE_NAME;
            }

            String classifierName = IDL_NormalizeUserDefinedClassifierName(elem.Name);
            if (parentName != null)
            {
                classifierName = parentName + "_" + classifierName;
            }
     
            String typeDeclaration = IDL_XSDbuiltin2IDLdeclaration(classifierName, baseClassName);
            if (typeDeclaration != null)
            {
                output.OutputTextLine(depth, typeDeclaration);
            }
            else
            {
                output.OutputTextLine(depth,
                   "typedef " + baseClassName + "     " + classifierName + ";");
            }
        }


        private static void GenIDL_XSDTopLevelAttribute(Repository repository, Element elem, String parentName,
             TextOutputInterface output, int depth)
        {
            // The attribute may reference an existing type. In this case GenIDL_GetTypeOfXSDSimpleType()
            // should resolve the type
            String baseClassName = GenIDL_GetTypeOfXSDSimpleType(repository, elem, parentName, output, depth);

            // If GenIDL_GetTypeOfXSDSimpleType() does not find the type, then it may be the case that the
            // attribute defines an simple type within it. This is similar to how elements in a XSD complex type
            // may define their types in-line. See GenIDL_NestedElements()
            if (baseClassName == null)
            {
                baseClassName = "/* Error cannot resolve type for XSDtopLevelAttribute */";

                if (elem.Elements.Count > 0)
                {
                    Element child = elem.Elements.GetAt(0);
                    baseClassName = GenIDL_GetTypeOfXSDSimpleType(repository, child, elem.Name, output, depth);
                }
            }

            if (baseClassName == null)
            {
                baseClassName = "/* Error cannot resolve type for XSDtopLevelAttribute */";
            }

            String classifierName = IDL_NormalizeUserDefinedClassifierName(elem.Name);
            if (parentName != null)
            {
                classifierName = parentName + "_" + classifierName;
            }


            String typeDeclaration = IDL_XSDbuiltin2IDLdeclaration(classifierName, baseClassName);
            if (typeDeclaration != null)
            {
                output.OutputTextLine(depth, typeDeclaration);
            }
            else
            {
                output.OutputTextLine(depth,
                   "typedef " + baseClassName + "     " + classifierName + ";");
            }
        }

        /*
         * Checks whether the class needs to be generated taking into consideration all 
         * the criteria below.
         * 
         * To anskwer yes all tjhe OK crteria have to be true and none of the NOT OK
         * crireria can be true.
         * 
         * - Is is an enum or some other type mapped to a typedef? NOT OK
         * - Optionally (if completionDB!=null), has it already been generated? NOT OK
         * - Is the element a class?  OK
         * - Is it checked in the selection tree? OK
         */
        private static bool GenIDL_MustGenerateClass(Repository repository, Element classElem,
             String elementPath, HashSet<String> uncheckedElem, 
             CodegenCompleteDatabase completionDB,
             TextOutputInterface output, int depth)
        {
            // Check that it is a class
            if (!IsClass(classElem))
            {
                return false;
            }

            // If already generated skip class
            if ((completionDB != null) && completionDB.IsClassGenerated(classElem) )
            {
                 return false;
            }

            // If unchecked, skip class
            if (IsElementUnchecked(uncheckedElem, elementPath, classElem.Name))
            {
                return false;
            }

            // These are generated in the first pass
            if (IsElementEnum(classElem))
            {
                return false;
            }

            // These are generated as typedef
            if ( IsXSDTypeMappedToTypedef(classElem) )
            {
                return false;
            }

            return true;
        }

        private static void GenIDL_EmptyClassContent(String className,
            TextOutputInterface output, int depth)
        {
            output.OutputTextLine(depth, "octet __dummy_prevent_empty_class_" + IDL_NormalizeUserDefinedClassifierName(className) + ";");
        }

        private static void GenIDL_EmptyModuleContent(String moduleName,
            TextOutputInterface output, int depth)
        {
            output.OutputTextLine(depth, "const long EmptyModule_Sentinel_" + moduleName + " = 0;");
        }

        /**
         * Checks that all the definitions this class depends on are already generated
         * This includes the base classes as well as any types that appear as
         * attributes and are not marked "@Shared"
         *
         */
        private static bool GenIDL_DependenciesAlreadyGenerated(Repository repository, Element classElem,
            TextOutputInterface output, CodegenCompleteDatabase completionDB, bool outputReport)
        {
            // Check base classes
            if (classElem.BaseClasses.Count > 0)
            {
                Object obj = classElem.BaseClasses.GetAt(0);
                Element elem = (Element)obj;
                if (!completionDB.IsClassIdGenerated(elem.ElementID))
                {
                    if (outputReport)
                    {
                        output.OutputText("    ( \"" + GenIDL_GetFullPackageName(repository, classElem) + "\" , \"" + classElem.Name + "\" )");
                        output.OutputText("  depends on  ( " + GenIDL_GetFullPackageName(repository, elem) + "\" , \"" + elem.Name + "\" )");
                        output.OutputTextLine("  dependency: baseclass");
                    }
                    return false;
                }
            }

            // Check atributes
            foreach (EA.Attribute child in classElem.Attributes)
            {
               if (child.ClassifierID == 0) /* Primitive type */
                {
                    continue;
                }
                if (!completionDB.IsClassIdGenerated(child.ClassifierID))
                {
                    // Not generated yet. It is only OK if this is by reference
                    if ( !IsAttributeReference(child) )
                    {
                        if (outputReport)
                        {
                            Element childTypeElem = repository.GetElementByID(child.ClassifierID);
                            output.OutputText("    ( \"" + GenIDL_GetFullPackageName(repository, classElem) + "\" , \"" + classElem.Name + "\" )");
                            output.OutputText("  depends on  ( " + GenIDL_GetFullPackageName(repository, childTypeElem) + "\" , \"" + childTypeElem.Name + "\" )");
                            output.OutputTextLine("   dependency:  attribute \"" + child.Name + "\"");
                        }

                        return false;
                    }
                }
            }

            // Check relationships (Aggregations only)
            String explanation;
            foreach (EA.Connector conn in classElem.Connectors)
            {
                ConnectorEnd thisElemEnd;
                ConnectorEnd referencedElemEnd;
                int referencedElemId;
                Element referencedElem;
                bool includeReferencedTypeAsMember;
                String memberName;
                bool includeAsReference;

                // Resolve the reference but ommit any explanatory text
                GenIDL_ReferenceDescriptor(repository, conn, classElem.ElementID, false,
                                            out thisElemEnd, out referencedElemEnd, out referencedElemId, out referencedElem,
                                            out memberName, out includeAsReference,
                                            out includeReferencedTypeAsMember, out explanation,
                                            output, 0);

                // If the reference did not have to be included, there there is no dependency on it.
                if ( includeReferencedTypeAsMember == false ) {
                    continue;
                }

                // If we are here then the referenced element must appear as a member. There is a depedency so we must make sure
                // that that class has already been generated
                if (!completionDB.IsClassIdGenerated(referencedElemId))
                {
                    if (outputReport)
                    {
                        output.OutputText("    ( \"" + GenIDL_GetFullPackageName(repository, classElem) + "\" , \"" + classElem.Name + "\" )");
                        output.OutputText("  depends on  ( " + GenIDL_GetFullPackageName(repository, referencedElem) + "\" , \"" + referencedElem.Name + "\" )");
                        output.OutputTextLine("   dependency:  aggregation \"" + memberName + "\"");
                    }

                    return false;
                }
            }

            return true;
        }

        /**
         *  Determines whether the attribute links the member by reference
         *  indicating that the type of the attribute does not need to be fully declared by
         *  the time we generate the IDL for the containing class.
         *
         *  This is true for attributes tagged "@Shared" and maybe others as well
         */
        private static bool IsAttributeReference(EA.Attribute member)
        {
            return (member.TaggedValues != null) && (EAUtil_FindChild(member.TaggedValues, "//@Shared") != null);
        }

        private static String GetIDL_getBaseClass(Repository repository, Element classElem)
        {
            String baseClassName = null;
            if (classElem.BaseClasses.Count > 0)
            {
                Object obj = classElem.BaseClasses.GetAt(0);
                Element elem = (Element)obj;
                baseClassName = GenIDL_GetFullPackageName(repository, elem)
                    + IDL_NormalizeUserDefinedClassifierName(elem.Name);

            }

            return baseClassName;
        }

        private static void GenIDL_Class(Repository repository, Element classElem,
            TextOutputInterface output, int depth,
            HashSet<String> uncheckedElem, String elementPath)
        {
            // If it generated as typedef there is nothing to do because we already generated a typedef for it...
            if ( IsXSDTypeMappedToTypedef(classElem) )
            {
                return;
            }

            String className = IDL_NormalizeUserDefinedClassifierName(classElem.Name);
            String baseClassName = GetIDL_getBaseClass(repository, classElem);

            // In IDL4 and higher annotations are before the class
            if  (idlVersion >= IDLVersion.IDL_V410_CONNEXT53) {
                GenIDL_ClassAnnotation(classElem, output, depth);
            }
            output.OutputText(depth, "struct " + className);

            if (baseClassName != null)
            {
                output.OutputText(" : " + baseClassName);
            }
            output.OutputTextLine(" {");

            bool emptyClassContent = true;
            if (GenIDL_Attributes(repository, classElem, output, depth + 1))
            {
                emptyClassContent = false;
            }
            if (GenIDL_Relations(repository, classElem, output, depth + 1))
            {
                emptyClassContent = false;
            }
            
            if (GenIDL_NestedElements(repository, classElem, output, depth + 1))
            {
                emptyClassContent = false;
            }

            if (emptyClassContent)
            {
                GenIDL_EmptyClassContent(className, output, depth + 1);
            }
            output.OutputText(depth, "};");

            // In IDL35 annotations may appear after the class as a comment
            if (idlVersion < IDLVersion.IDL_V410_CONNEXT53)
            {
                GenIDL_ClassAnnotation(classElem, output, depth);
            }
            output.OutputTextLine();
        }

        private static int GenIDL_ClassAnnotation(Element classElem,
            TextOutputInterface output, int depth)
        {
            string[] relevantAnnotationsNoValue = new string[] {
                "autoid",
                "final", "mutable", "extensible",
                "service"
            };
            string[] relevantAnnotationsWithValue = new string[] {
                "Extensibility", "verbatim", "nested"
            };

            string ddsTag = "DDS";

            int annotationCount = 0;
            foreach (TaggedValue tag in classElem.TaggedValues)
            {
                String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name);

                // Accept the TagName DDS as an alternative way to provide an accepted no value annotation
                // So {Tag, Value} = {"DDS", "XYZ"} is equivalent to {"XYZ", }
                if (normalizedAnnotation.Equals(ddsTag))
                {
                    normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Value);
                }

                if (relevantAnnotationsNoValue.Contains(normalizedAnnotation))
                {
                    GenIDL_Annotation(normalizedAnnotation, annotationCount == 0, output, depth);
                    output.OutputTextLine();
                    ++annotationCount;
                }
                else if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                {
                    GenIDL_Annotation(normalizedAnnotation, tag.Value, annotationCount == 0, output, depth);
                    output.OutputTextLine();
                    ++annotationCount;
                }
                else
                {
                    if ((idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL))
                    {
                        output.OutputTextLine(depth, "/* Skipping unknown annotation name:\"" + tag.Name + "\" value: \"" + tag.Value + "\" */");
                    }
                }
            }

            return annotationCount;
        }


        private static char[] invalidTypenameChars = new char[] { ' ', '-', '&', '(', ')', '/', '?'};
        private static char[] recognizedUnicodeCharsInput = new char[] { '', '', '', '' };
        private static char[] recognizedUnicodeCharOutput = new char[] { '2', '3', 'd', 'u' };

        /**  Normalizes a user-defined UML classifier (class / package) name into a legal IDL class/module name
         *
         */
        public static String IDL_NormalizeUserDefinedClassifierName(String classifierName)
        {
            String normalizedName = classifierName;

            // DO special transformation for some recognized unicode characters
            for (int index = 0; index < recognizedUnicodeCharsInput.GetLength(0); ++index)
            {
                normalizedName = normalizedName.Replace(recognizedUnicodeCharsInput[index], recognizedUnicodeCharOutput[index]);
            }

            // The rest of the unicode characters get replaced by "?" 
            normalizedName = Encoding.ASCII.GetString(Encoding.ASCII.GetBytes(normalizedName));

            // This replaces any ascci characters that are not valid in identifiers (including ?)
            for (int index = 0; index < invalidTypenameChars.GetLength(0); ++index) {
                normalizedName = normalizedName.Replace(invalidTypenameChars[index], '_');
            }

            return normalizedName;
        }

        private static readonly string[] boolTypes      = new string[] { "boolean", "bool" };
        private static readonly string[] charTypes      = new string[] { "char" };
        private static readonly string[] wcharTypes     = new string[] { "wchar", "wchar_t" };

        private static readonly string[] longlongTypes  = new string[] { "long long", "int64", "int64_t" };
        private static readonly string[] ulonglongTypes = new string[] { "unsigned long long", "uint64", "uint64_t" };
        private static readonly string[] longTypes      = new string[] { "long", "int", "int32", "int32_t", "integer", "decimal", "unlimitednatural"};
        private static readonly string[] ulongTypes     = new string[] { "unsigned long", "unsigned int", "ulong", "uint", "uint32", "uint32_t" };
        private static readonly string[] shortTypes     = new string[] { "short", "int16", "int16_t" };
        private static readonly string[] ushortTypes    = new string[] { "unsigned short", "ushort", "uint16", "uint16_t" };
        private static readonly string[] octetTypes     = new string[] { "octet", "byte", "sbyte", "int8", "int8_t", "uint8", "uint8_t" };
        private static readonly string[] floatTypes     = new string[] { "float", "float32", "number", "real" };
        private static readonly string[] doubleTypes    = new string[] { "double", "float64" };
        private static readonly string[] stringTypes    = new string[] { "string", "String" };
        private static readonly string[] wstringTypes   = new string[] { "wstring" };

        private static readonly string[][] primtiveTypeVariations = {
            boolTypes, charTypes, wcharTypes, 
            longlongTypes, ulonglongTypes, longTypes, ulongTypes, shortTypes, ushortTypes, octetTypes, floatTypes, doubleTypes, 
            stringTypes,  wstringTypes };

        private static readonly Regex MultipleSpaces = new Regex(@" {2,}", RegexOptions.Compiled);

        /** Normalizes a type name converting it into a legal IDL4  type.
         *
         * This function handles common variations of primitive type names. For anything non-primitive
         * it just calls IDL_NormalizeUserDefinedClassifierName
         */
        private static String IDL_NormalizeMemberTypeName(String typeName)
        {
            String normalizedType = MultipleSpaces.Replace(typeName, " ");
            for (int typeFamily = 0; typeFamily < primtiveTypeVariations.GetLength(0); ++typeFamily)
            {
                if (primtiveTypeVariations[typeFamily].Contains(normalizedType.ToLower()))
                {
                    return primtiveTypeVariations[typeFamily][0];
                }
            }

            return IDL_NormalizeUserDefinedClassifierName(normalizedType);
        }

        // This list needs to be consistent with the types generated by GenIDL_PrebuiltUMLTypes
        // The list is now empty. Used to contain dateTime but we are now mapping to string.
        private static readonly string[] umlExtensionTypes = new string[] { "dateTime" };

        /** Normalizes a type name converting it into a legal IDL4  type.
         *
         * Like IDL_NormalizeMemberTypeName() except specialized to types with classifierID=0
         * TODO: Need to verify whether primitive types always have classifierID=0 in which case
         * IDL_NormalizeMemberTypeName should be rewriten
         */
        private static String IDL_NormalizeMemberTypeNameClassiffiedID0(String typeName)
        {
            String normalizedType = MultipleSpaces.Replace(typeName, " ");
            for (int typeFamily = 0; typeFamily < primtiveTypeVariations.GetLength(0); ++typeFamily)
            {
                if (primtiveTypeVariations[typeFamily].Contains(normalizedType.ToLower()))
                {
                    return primtiveTypeVariations[typeFamily][0];
                }
            }

            if (umlExtensionTypes.Contains(typeName) )
            {
                return UML_EXTENSION_MODULE_NAME + "::" + typeName;
            }

            return IDL_NormalizeUserDefinedClassifierName(normalizedType);
        }

        private static readonly string[] keyAnnotation = new string[] { "Key", "key" };
        private static readonly string[] mustUnderstandAnnotation = new string[] { "must_understand" };

        private static readonly string[] idAnnotation = new string[] { "ID", "id" };
        private static readonly string[] autoidAnnotation = new string[] { "autoid" };
        private static readonly string[] optionalAnnotation = new string[] { "Optional", "optional" };
        private static readonly string[] valueAnnotation = new string[] { "value" };

        private static readonly string[] extensibilityAnnotation = new string[] { "Extensibility", "extensibility" };
        private static readonly string[] finalAnnotation = new string[] { "final" };
        private static readonly string[] mutableAnnotation = new string[] { "mutable" };

        private static readonly string[] defaultAnnotation = new string[] { "default" };
        private static readonly string[] rangeAnnotation = new string[] { "range" };
        private static readonly string[] minAnnotation = new string[] { "min" };
        private static readonly string[] maxAnnotation = new string[] { "max" };
        private static readonly string[] unitAnnotation = new string[] { "unit" };

        private static readonly string[] bitBoundAnnotation = new string[] { "bit_bound" };
        private static readonly string[] externalAnnotation = new string[] { "external" };
        private static readonly string[] nestedAnnotation = new string[] { "nested" };

        private static readonly string[] verbatimAnnotation = new string[] { "verbatim" };

        private static readonly string[] serviceAnnotation = new string[] { "service" };
        private static readonly string[] onewayAnnotation = new string[] { "oneway" };
        private static readonly string[] amiAnnotation = new string[]   { "ami" };

        // Not strictly a IDL3.5, 4, or XTYPES annotation but something users do sometimes
        private static readonly string[] ddsAnnotation = new string[] { "DDS", "dds" };

        private static readonly string[][] builtinAnnotationVariations = {
            keyAnnotation, mustUnderstandAnnotation,
            idAnnotation, autoidAnnotation, optionalAnnotation, valueAnnotation,
            extensibilityAnnotation, finalAnnotation, mutableAnnotation,
            defaultAnnotation, rangeAnnotation, minAnnotation, maxAnnotation, unitAnnotation,
            bitBoundAnnotation, externalAnnotation, nestedAnnotation,
            verbatimAnnotation,
            serviceAnnotation, onewayAnnotation, amiAnnotation,
            ddsAnnotation
        };

        /** Normalizes an annotation type name converting it into a legal IDL4 / Connext DDS annotation.
         *
         * This function handles common variations of capitalization for the builtin annotations. For anything
         * non-built-in it just leaves it unchanged
         */
        private static String IDL_NormalizeAnnotationName(String annotationName)
        {
            String annotationNameLower = annotationName.ToLower();
            for (int annotationType = 0; annotationType < builtinAnnotationVariations.GetLength(0); ++annotationType)
            {
                if ( builtinAnnotationVariations[annotationType].Contains(annotationNameLower) )
                {
                    return builtinAnnotationVariations[annotationType][0];
                }
            }

            return annotationName;
        }

        /**
         * Determines whether this is a model element relevant to Connext DDS and we need to
         * generate code associated with the model element.
         */
        private static bool IsClass(Element e)
        {
            return (e.Type == "Class");
        }

        private static bool IsEmptyClass(Element e)
        {
            return (e.Attributes.Count == 0) && (e.Connectors.Count == 0);
        }


        internal static void setIdlVersion(int p)
        {
            Main.idlVersion = p;
        }

        internal static void setIdlMappingDetail(int p)
        {
            Main.idlMappingDetail = p;
        }

    }
}
